use empath_common::{Signal, context::Context};

use crate::{
    backends::{FileBackingStore, MemoryBackingStore, TestBackingStore},
    r#trait::BackingStore,
    types::SpooledMessageId,
};

/// Main Spool struct - generic over backing store
///
/// This provides a unified interface for message spooling, regardless of
/// the underlying storage mechanism. The generic parameter `T` allows for
/// zero-cost abstraction when using concrete types, while still supporting
/// trait objects (`Arc<dyn BackingStore>`) for dynamic dispatch.
///
/// # Type Parameters
/// * `T` - The backing store implementation
///
/// # Examples
/// ```ignore
/// // Memory-backed spool for testing
/// let spool = Spool::new(MemoryBackingStore::new());
///
/// // File-backed spool for production
/// let store = FileBackingStore::builder()
///     .path(PathBuf::from("/var/spool/empath"))
///     .build()?;
/// let spool = Spool::new(store);
///
/// // Trait object for polymorphism
/// let store: Arc<dyn BackingStore> = Arc::new(MemoryBackingStore::new());
/// ```
#[derive(Debug, serde::Deserialize)]
#[serde(transparent)]
pub struct Spool<T: BackingStore> {
    #[serde(bound(deserialize = "T: serde::Deserialize<'de>"))]
    store: T,
}

impl<T: BackingStore + Default> Default for Spool<T> {
    fn default() -> Self {
        Self {
            store: T::default(),
        }
    }
}

impl<T: BackingStore> Spool<T> {
    /// Create a new spool with the given backing store
    #[must_use]
    pub const fn new(store: T) -> Self {
        Self { store }
    }

    /// Spool a context to the backing store and return its tracking ID
    ///
    /// The tracking ID is generated by the backing store and is guaranteed to be unique.
    ///
    /// # Errors
    /// Returns an error if the context cannot be written to the backing store
    pub async fn spool_message(&self, context: &mut Context) -> crate::Result<SpooledMessageId> {
        self.store.write(context).await
    }

    /// List all spooled message identifiers
    ///
    /// # Errors
    /// Returns an error if the backing store cannot be read
    pub async fn list_messages(&self) -> crate::Result<Vec<SpooledMessageId>> {
        self.store.list().await
    }

    /// Read a specific message from the spool and return its full context
    ///
    /// # Errors
    /// Returns an error if the message cannot be found or read
    pub async fn read_message(&self, id: &SpooledMessageId) -> crate::Result<Context> {
        self.store.read(id).await
    }

    /// Delete a message from the spool
    ///
    /// # Errors
    /// Returns an error if the message cannot be deleted
    pub async fn delete_message(&self, id: &SpooledMessageId) -> crate::Result<()> {
        self.store.delete(id).await
    }

    /// Access the underlying backing store
    ///
    /// This is useful for store-specific operations not exposed through
    /// the standard Spool interface.
    #[must_use]
    pub const fn store(&self) -> &T {
        &self.store
    }

    /// Mutably access the underlying backing store
    #[must_use]
    pub const fn store_mut(&mut self) -> &mut T {
        &mut self.store
    }
}

/// Clone implementation - only available when T is Clone
///
/// This allows cheap cloning for backing stores that use Arc internally,
/// while preventing cloning for stores where it doesn't make sense.
impl<T: BackingStore + Clone> Clone for Spool<T> {
    fn clone(&self) -> Self {
        Self {
            store: self.store.clone(),
        }
    }
}

/// Type alias for memory-backed spool
pub type MemorySpool = Spool<MemoryBackingStore>;

/// Type alias for test spool
pub type TestSpool = Spool<TestBackingStore>;

/// Type alias for file-backed spool
pub type FileSpool = Spool<FileBackingStore>;

/// FileBackingStore-specific methods on Spool
///
/// These methods are only available when using a file-backed spool.
/// They handle lifecycle operations specific to file storage.
impl Spool<FileBackingStore> {
    /// Initialize the file-backed spool
    ///
    /// Creates directories, validates paths, etc.
    ///
    /// # Errors
    /// Returns an error if initialization fails
    pub fn init(&mut self) -> crate::Result<()> {
        self.store_mut().init()
    }

    /// Serve the spool directory
    ///
    /// Watches the spool directory and handles shutdown signals.
    ///
    /// # Errors
    /// Returns an error if serving fails
    pub async fn serve(
        &self,
        shutdown: tokio::sync::broadcast::Receiver<Signal>,
    ) -> crate::Result<()> {
        self.store().serve(shutdown).await
    }
}

#[cfg(test)]
#[allow(clippy::expect_used, clippy::unwrap_used)]
mod tests {
    use std::sync::Arc;

    use ahash::AHashMap;
    use empath_common::envelope::Envelope;

    use super::*;

    fn create_test_context(data: &str) -> Context {
        Context {
            envelope: Envelope::default(),
            data: Some(Arc::from(data.as_bytes())),
            id: "test.example.com".to_string(),
            extended: false,
            metadata: AHashMap::new(),
            ..Default::default()
        }
    }

    #[tokio::test]
    #[cfg_attr(miri, ignore = "Calls an unsupported method")]
    async fn test_spool_wrapper() {
        let store = MemoryBackingStore::new();
        let spool = Spool::new(store);

        let mut message = create_test_context("test message");
        let expected_data = message.data.clone();

        // Test through Spool interface and get tracking ID
        let id = spool
            .spool_message(&mut message)
            .await
            .expect("Failed to spool");

        let ids = spool.list_messages().await.expect("Failed to list");
        assert_eq!(ids.len(), 1);
        assert_eq!(ids[0], id);

        let read_msg = spool.read_message(&id).await.expect("Failed to read");
        assert_eq!(read_msg.data.as_ref(), expected_data.as_ref());

        spool.delete_message(&id).await.expect("Failed to delete");

        let ids_after = spool.list_messages().await.expect("Failed to list");
        assert_eq!(ids_after.len(), 0);
    }

    #[tokio::test]
    #[cfg_attr(miri, ignore = "Calls an unsupported method")]
    async fn test_polymorphic_backing_store() {
        // Test that we can use trait objects
        let store: Arc<dyn BackingStore> = Arc::new(MemoryBackingStore::new());
        let mut message = create_test_context("polymorphic test");
        let expected_data = message.data.clone();

        let id = store.write(&mut message).await.expect("Failed to write");
        let ids = store.list().await.expect("Failed to list");
        assert_eq!(ids.len(), 1);
        assert_eq!(ids[0], id);

        let read_msg = store.read(&id).await.expect("Failed to read");
        assert_eq!(read_msg.data.as_ref(), expected_data.as_ref());
    }
}
