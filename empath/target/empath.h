#pragma once

/**
     * Warning, this file is autogenerated by cbindgen. Don't modify this manually.
     * Instead, alter build.rs, or the respective rust item.
     **/

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define EM_DECLARE_MODULE(ty, ...) Mod declare_module() { return (Mod){ty ## Listener, {__VA_ARGS__}}; }


typedef enum Ev {
  ConnectionOpened,
  ConnectionClosed,
} Ev;

typedef struct Context Context;

typedef struct String {
  uintptr_t len;
  const int8_t *data;
} String;

typedef struct StringVector {
  uintptr_t len;
  const struct String *data;
} StringVector;

typedef int32_t (*Init)(struct StringVector);

typedef struct Validators {
  int32_t (*validate_connect)(struct Context*);
  int32_t (*validate_mail_from)(struct Context*);
  int32_t (*validate_data)(struct Context*);
  int32_t (*validate_starttls)(struct Context*);
} Validators;

typedef struct Validation {
  const char *module_name;
  Init init;
  struct Validators validators;
} Validation;

typedef enum Mod_Tag {
  ValidationListener,
  EventListener,
} Mod_Tag;

typedef struct EventListener_Body {
  const char *module_name;
  Init init;
  int32_t (*emit)(enum Ev, struct Context*);
} EventListener_Body;

typedef struct Mod {
  Mod_Tag tag;
  union {
    struct {
      struct Validation validation_listener;
    };
    EventListener_Body event_listener;
  };
} Mod;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 *
 * This solely exists in order to have the `Validation` be parsed
 * by cbindgen. Perhaps in future it will be done in a better way.
 *
 */
struct Mod *__cbindgen_hack_please_remove(void);

void em_free_string(struct String ffi_string);

void em_free_string_vector(struct StringVector ffi_vector);

/**
 * Retrieve the id associated with this context
 *
 * This is the only way to retrieve the id for the context in an
 * ffi-compatible way. Any other way should be retrieved by
 * accessing the id member directly.
 *
 */
struct String em_context_get_id(const struct Context *validate_context);

struct StringVector em_context_get_recipients(const struct Context *validate_context);

struct String em_context_get_sender(const struct Context *validate_context);

/**
 *
 * Set the sender for the message. A special value of NULL will set the
 * sender to the NULL Sender.
 *
 * # Safety
 *
 * This should be able to be passed any valid pointer, and a valid `validate_context`, to
 * set the sender
 *
 */
bool em_context_set_sender(struct Context *validate_context, const char *sender);

struct String em_context_get_data(const struct Context *validate_context);

/**
 *
 * # Safety
 *
 * Even if provided with a null pointer, that would simply set the response to `None`
 *
 */
bool em_context_set_response(struct Context *validate_context,
                             uint32_t status,
                             const char *response);

bool em_context_is_tls(const struct Context *validate_context);

struct String em_context_tls_protocol(const struct Context *validate_context);

struct String em_context_tls_cipher(const struct Context *validate_context);

/**
 *
 * # Safety
 *
 * Provided with a null pointer, simply return false
 *
 */
bool em_context_exists(const struct Context *validate_context, const char *key);

/**
 *
 * # Safety
 *
 * Provided with a null pointer, simply return false
 *
 */
bool em_context_set(struct Context *validate_context, const char *key, const char *value);

/**
 *
 * # Safety
 *
 * Provided with a null pointer, simply return a default value
 *
 */
struct String em_context_get(const struct Context *validate_context, const char *key);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
